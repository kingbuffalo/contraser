package map_db

//import (
//	"encoding/json"
//	"errors"
//	"fmt"
//	"github.com/kingbuffalo/seelog"
//	"io/ioutil"
//	//"math/rand"
//	//"strconv"
//	//"buffalo/king/common/gameutil"
//	//"buffalo/king/common/startcfg"
//)
//
///*
//æ­¤æ•°æ®ä¸ç”¨è½åœ°
//æ”¾rediså°±å¯ä»¥
//*/
//
//type Layers_t struct {
//	Height uint32  `json:"height"`
//	Data   []int32 `json:"data"`
//	Width  uint32  `json:"width"`
//	X      uint32  `json:"x"`
//	Y      uint32  `json:"y"`
//	//	Visible bool    `json:"visible"`
//	//	Type    string  `json:"type"`
//	//	Opacity uint32  `json:"opacity"`
//	//	Name    string  `json:"name"`
//}
//
//type MapV0 struct {
//	//	Height   uint32     `json:height`
//	//	Infinite bool       `json:"infinite"`
//	Layers []Layers_t `json:"layers"`
//}
//
//var mapInstance MapV0
//var AvailableLocation []uint32 //
//var LenLocation uint32
//
//func InitCfgPoint() {
//
//}
//func init() {
//	//path := startcfg.GetCfgPath()
//	//fn := path + "cfg_Monthsign.json"
//	fn := "/home/gbb/go/src/buffalo/king/script/cfgjson/map_1.json"
//	seelog.Trace("init config file :", fn)
//	b, err := ioutil.ReadFile(fn)
//	if err != nil {
//		panic(err)
//	}
//	if err = json.Unmarshal(b, &mapInstance); err != nil {
//		panic(err)
//	}
//	if len(mapInstance.Layers) < 1 || len(mapInstance.Layers[0].Data) != int(mapInstance.Layers[0].Width*mapInstance.Layers[0].Height) {
//		panic(errors.New("Data SIZE != Width * Height"))
//	}
//
//	//æ‰“å°å‡ºä¸€äº›ä¿¡æ¯æ¥
//	fmt.Println("size, datasize, width,height :", len(mapInstance.Layers), len(mapInstance.Layers[0].Data), mapInstance.Layers[0].Width, mapInstance.Layers[0].Height)
//	//æ ¹æ®3*3 çš„å¤§å°æ¥ç¡®å®šç‚¹çš„ç°åº¦
//	for i := 0; i < len(mapInstance.Layers[0].Data); i++ {
//		if mapInstance.Layers[0].Data[i] > 0 {
//			pointSet := GetEightPoint(uint32(i), mapInstance.Layers[0].Width, mapInstance.Layers[0].Height)
//			for j := 0; j < len(pointSet); j++ {
//				if pointSet[j] >= 0 {
//					mapInstance.Layers[0].Data[j] = 1061
//				}
//			}
//		}
//	}
//	//å…ˆåˆ¤æ–­
//
//	//æœ€åå†ç½®ç°ï¼Œæœ€åäºŒæ’å’Œæœ€å³äºŒæ’
//	for i := int(mapInstance.Layers[0].Width); i <= len(mapInstance.Layers[0].Data); {
//		mapInstance.Layers[0].Data[i-1] = 1061
//		mapInstance.Layers[0].Data[i-2] = 1061
//		i = i + int(mapInstance.Layers[0].Width)
//	}
//	for i := int(mapInstance.Layers[0].Height-2)*int(mapInstance.Layers[0].Width) - 1; i < len(mapInstance.Layers[0].Data); i++ {
//		mapInstance.Layers[0].Data[i] = 1061
//	}
//	var j int = 0
//	for i := 0; i < len(mapInstance.Layers[0].Data); i++ {
//		if mapInstance.Layers[0].Data[i] == 0 {
//			AvailableLocation[j] = uint32(i)
//			j = j + 1
//		}
//	}
//
//	LenLocation = uint32(len(AvailableLocation))
//	if LenLocation <= 7 {
//		panic(errors.New("AvailableLocation is too short"))
//	}
//	//var AvailableLocation []uint32
//
//}
//func GetEightPoint(location uint32, width uint32, height uint32) [8]int {
//	var Point [8]int
//	//ç½®ç° å·¦ä¸Šè§’ 8ä¸ªç©ºæ ¼ï¼Œ å·¦ä¸Šè§’çš„ç®—æ³•åˆ†åˆ«æ˜¯ (x-2, y-2) (x-1, y-2) (x, y-2) (x-2,y-1)(x-1,y-1)( x,y-1) (x-2,y) (x-1,y) å¯¹äºä¸€ç»´æ•°ç»„æ¥è¯´ï¼Œè¿™ä¹ä¸ªè§’åˆ†åˆ«åº”è¯¥æ˜¯
//	//è¿˜è¦çœ‹è¯¥ä½ç½®æ˜¯å¦å¤„äºç¬¬ä¸€åˆ—æˆ–è€…ç¬¬äºŒåˆ—ï¼Œå¦‚æœå¤„äº,å°±ä¸ç”¨æŠ˜è…¾äº†ï¼Œ
//	//å¯¹äºæ˜¯å¦å¤„äºç¬¬ä¸€è¡Œæˆ–è€…ç¬¬äºŒè¡Œï¼Œè‘—éœ€è¦å‡å®Œä»¥åï¼Œè¿›è¡Œ>= çš„æ“ä½œå°±å¯ä»¥äº†
//	if location%width == 0 {
//		Point[0] = -1
//		Point[1] = -1
//		Point[3] = -1
//		Point[4] = -1
//		Point[6] = -1
//		Point[7] = -1
//		//é‚£ä¹ˆå°±ä¸éœ€è¦
//	} else if location%width == 1 {
//		Point[0] = -1
//		Point[3] = -1
//		Point[6] = -1
//		Point[1] = int(location - 2*width - 1)
//		Point[4] = int(location - width - 0)
//		Point[7] = int(location - 1)
//	} else {
//		Point[0] = int(location - 2*width - 2)
//		Point[3] = int(location - width - 2)
//		Point[6] = int(location - 2)
//		Point[1] = int(location - 2*width - 1)
//		Point[4] = int(location - width - 1)
//		Point[7] = int(location - 1)
//	}
//	Point[2] = int(location - 2*width)
//	Point[5] = int(location - width)
//	return Point
//	//	(x-1,y) ===> i-1 [] //[7]
//	//	(x-2, y) ===> i-2 //[6]
//	//	( x,y-1 )===> i-1*width //[5]
//	//	(x-1,y-1)====> i-1*width -1 //[4]
//	//	(x-2,y-1)====> i-1*width -2  //[3]
//	//	(x, y-2) ==> i-2*width    //[2]
//	//	(x-1, y-2) ==> i-2*width-1 //[1]
//	//	(x-2, y-2) ==> i-2*width-2 //[0]
//
//}
//
////äº§ç”ŸåŸæ± éœ€è¦6ä¸ªä½ç½®ä¿¡æ¯
////åªæœ‰åœ¨æœ€åçš„æ—¶å€™ï¼Œæ‰æŠŠè¿™ä¸ªä½ç½®è½¬æ¢ä¸ºåæ ‡ï¼Œå…¶ä»–å…¨éƒ¨æ˜¯ä¸€ç»´æ•°ç»„è¿›è¡Œ
//type CityPoint struct {
//	X uint32 `json:"x"`
//	Y uint32 `json:"y"`
//}
//
////å…ˆä¸å¯¹è‡ªå·±åšä¸­é—´ä½ç½®çš„å¤„ç† ,å¯ä»¥å¯¹äº§ç”Ÿçš„ç‚¹è¿›è¡Œç­›é€‰
////func GenerateMyCity() CityPoint {
////	//æš‚æ—¶è®©mycity å¤„äº 1/3-- 2/3å¤„
////	start_point := int(LenLocation / 3)
////	lct := rand.Intn(start_point) + start_point
////	return location2CityPoint(AvailableLocation[lct])
////}
//
////func Generate(num uint32) []CityPoint {
////
////}
//func location2CityPoint(location uint32) CityPoint {
//	//æŠŠè¿™ä¸ªä½ç½®è½¬æ¢ä¸º ç‚¹
//	var cityPoint CityPoint
//	cityPoint.X = location / GetWidth()
//	cityPoint.Y = location % GetHeight()
//	return cityPoint
//
//}
//
////å¦‚æœçœŸçš„å­˜åœ¨äº§ç”Ÿ å¤±è´¥çš„æƒ…å†µï¼Œå°±è¿”å›ï¼ˆ0ï¼Œ0ï¼‰
////data åº”è¯¥ä»¥å¼•ç”¨è¿›å…¥ï¼Œä¸‹é¢è¦å¾ªç¯ä½¿ç”¨è¿™ä¸ªå€¼ï¼Œä½†æ˜¯å¦ä¸€ä¸ªå‘¢ï¼Ÿæ¯æ¬¡è¿”å›å˜›ï¼Ÿä¹Ÿä»¥& è¿›å…¥å¥½äº†ï¼Œæœ€åæ›´æ–°è¿™ä¸ªå€¼å¥½äº†ï¼Œä¸ç„¶æ•°ç»„çš„å¤§å°ä¸å¥½ç¼©å°ï¼Œä¼š[C]ç¼ èº«
////è¿™ç§åŠæ³•æ¯”è¾ƒç¬¨ï¼Œå¯ä»¥è€ƒè™‘å›ºè¯å‡ ä¸ªç‚¹ï¼Œä»¥ç¡®è®¤100% å¯ä»¥äº§ç”Ÿé‚£ä¹ˆå¤šä¸ªç‚¹ï¼Œä½†æ˜¯è¿™ä¸ªå›ºè¯çš„è¿‡ç¨‹ï¼Œè¦æ€ä¹ˆåšå‘¢? å°½å¯èƒ½å¤šçš„äº§ç”Ÿï¼Œå°±æ˜¯å°½å¯èƒ½é€‰ç”¨å·¦ä¸Šè§’çš„æ•°æ®ä½œä¸ºæœ€åçš„ç­”æ¡ˆï¼Œä½†æ˜¯è¿™æ ·æ˜¯å¦åˆé—®é¢˜å‘¢ï¼Ÿ
////å…ˆè¿™ä¹ˆåšå§ åæœŸå†æƒ³æ›´å¥½çš„æ–¹æ¡ˆï¼Œæ•ˆç‡æ–¹é¢å‘¢ï¼Ÿ ä¼šä¸ä¼šæœ‰é—®é¢˜ï¼Ÿæ²¡æœ‰ç½‘ç»œå¼€é”€åº”è¯¥æ— æ‰€è°“å§~
////func subGenerateCity(Matrix []uint32, Data []uint32) ([]uint32, CityPoint, error) {
////	var point CityPoint
////	len := len(Matrix)
////	lct := rand.Intn(len)
////}
//
////var AvailableLocation []uint32 //
////
////CityPoint[0] = GenerateMyCity()
//
////uint32 mycity
////å…ˆäº§ç”Ÿè‡ªå·±çš„ä½ç½® (å¸Œæœ›åˆ†å¸ƒåœ¨ä¸­é—´éƒ¨åˆ† ä¹Ÿå°±æ˜¯ 1/3- 2/3 éƒ¨åˆ†)
//// éšæœºåˆ°ä¸€ä¸ªä½ç½®ä½œä¸ºè‡ªå·±çš„ï¼Œæ”¾åœ¨è¿”å›çš„ç¬¬ä¸€ä¸ªä½ç½®
//
////	å‡å®šæ‰€æœ‰çš„åŸæ± éƒ½æ˜¯ 3*3 çš„
////	äº§ç”Ÿéšæœº å¤šä¸ªåŸæ±  å¦‚ä½•éšæœºäº§ç”Ÿå‘¢?
////func GenerateCity(neighbour uint32) []CityPoint {
////	var CitySet []CityPoint
////	//å…ˆè¿›è¡Œèµ‹å€¼ï¼Œç„¶åå¯¹è¿™ä¸¤ä¸ªè¿›è¡Œæ”¹å˜
////	Date := GetData()
////	RestIndex := AvailableLocation
////	for i := 0; i < neighbour; i++ {
////		var Layout []uint32
////		Point, err := subGenerateCity(&RestIndex, &Date)
////		if err != nil {
////			seelog.Trace("No new points can be generated")
////			break
////		}
////		CitySet[i] = Point
////	}
////	return CitySet
////
////}
////
//func GetWidth() uint32 {
//	return mapInstance.Layers[0].Width
//}
//func GetHeight() uint32 {
//	return mapInstance.Layers[0].Height
//}
//func GetData() []int32 {
//	return mapInstance.Layers[0].Data
//}
